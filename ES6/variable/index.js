/** ***********************数组的解构****************************** */
let a = 1;
let b = 2;
let c = 3;
console.log('a=' + a + ', b=' + b + ', c=' + c);
let [d, e, f] = [4, 5, 6];//  ES6为变量赋值新方法,属于模式匹配
console.log('d=' + d + ', e=' + e + ', f=' + f);
/** ***************************************************** */
let [head, ...foot] = [1, 2, 3, 4];// 模式匹配:只要等号两边的模式相同，左边的变量就会被赋予对应的值。
let [x, y, ...z] = ['a'];
console.log('head = ' + head + ', foot =' + foot);
console.log('x = ' + x + ', y =' + y + ', z = ' + z);// x=a,y=undefined,z=空
/** ***************************************************** */
let [m, n = 'b'] = ['a'];// 解构赋值设置默认值，变量解构时如果没有赋值就用默认值
console.log('m = ' + m + ', n = ' + n);
let [m1, n1 = 'b', p] = ['a', undefined, null];
console.log('m1 = ' + m1 + ', n1 = ' + n1, 'p = ' + p);// ES6内部使用严格相等===运算符判断一个位置是否有值，所以只有这个值严格等于undefined，默认值才会生效
/** *******************对象也可以结构赋值********************** */
const node = {
  loc: {
    start: {
      line: 1,
      column: 5,
    },
  },
};
let { loc, loc: { start }, loc: { start: { line } } } = node;
console.log('loc = ' + JSON.stringify(loc) + ', line = ' + line + ', start = ' + start);
/** ********************************************************* */

/** *********************解构赋值的用途：********************** */
let x1 = 2;
let y1 = 3;
console.log('x1 = ' + x1 + ', y1 = ' + y1);
[y1, x1] = [x1, y1];
console.log('交换顺序后的x1 = ' + x1 + ', y1 = ' + y1);
/** ************************函数参数************************** */
function ff({ x2, y2, z2 }) {
  let x22 = x2;
  let y22 = y2;
  let z22 = z2;
  return [x22, y22, z22];
}
ff({ z2: 1, x2: 3, y2: 2 });
